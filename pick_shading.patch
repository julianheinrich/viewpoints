diff --git a/data/shaders/default.fs b/data/shaders/default.fs
index c8f6f8b..bb960bb 100644
--- a/data/shaders/default.fs
+++ b/data/shaders/default.fs
@@ -1,11 +1,16 @@
 #include webgl_header.fs
 
 varying vec3 packed_data_0 ;
-varying vec4 packed_data_3 ;
 varying float fog;
 varying vec2 bgTextureLookup;
 
-#define COLOR packed_data_3
+#ifdef PURE_OPENGL_ES_2
+varying vec4 COLOR;
+#else
+// using the built-in allows to use glShadeModel
+#define COLOR gl_Color
+#endif
+
 #define NORMAL normalize(packed_data_0.xyz)
 
 uniform bool lighting_enabled;
diff --git a/data/shaders/default.vs b/data/shaders/default.vs
index a9e3e3f..1deecdc 100644
--- a/data/shaders/default.vs
+++ b/data/shaders/default.vs
@@ -5,11 +5,16 @@ attribute vec3 a_Normal;
 attribute vec4 a_Color;
 
 varying vec3 packed_data_0 ;
-varying vec4 packed_data_3 ;
 
 //varying vec3 N;
 #define NORMAL  packed_data_0
-#define COLOR packed_data_3
+
+#ifdef PURE_OPENGL_ES_2
+varying vec4 COLOR;
+#else
+// using the built-in allows to use glShadeModel
+#define COLOR gl_FrontColor
+#endif
 
 varying float fog;
 varying vec2 bgTextureLookup;
diff --git a/data/shaders/surface.fs b/data/shaders/surface.fs
index dd6798f..3606afe 100644
--- a/data/shaders/surface.fs
+++ b/data/shaders/surface.fs
@@ -1,11 +1,16 @@
 #include webgl_header.fs
 
 varying vec3 packed_data_0 ;
-varying vec4 packed_data_3 ;
 varying float fog;
 varying vec2 bgTextureLookup;
 
-#define COLOR packed_data_3
+#ifdef PURE_OPENGL_ES_2
+varying vec4 COLOR;
+#else
+// using the built-in allows to use glShadeModel
+#define COLOR gl_Color
+#endif
+
 #define NORMAL normalize(packed_data_0.xyz)
 
 uniform bool lighting_enabled;
diff --git a/data/shaders/surface.vs b/data/shaders/surface.vs
index 75978a7..ef518df 100644
--- a/data/shaders/surface.vs
+++ b/data/shaders/surface.vs
@@ -10,12 +10,18 @@ attribute float a_Accessibility; /* This is for ambient occlusion, 1.0 by defaul
 varying vec3 packed_data_0 ;
 varying vec4 packed_data_1 ;
 varying vec4 packed_data_2 ;
-varying vec4 packed_data_3 ;
 varying vec4 packed_data_4 ;
 
 //varying vec3 N;
 #define NORMAL  packed_data_0
-#define COLOR packed_data_3
+
+#ifdef PURE_OPENGL_ES_2
+varying vec4 COLOR;
+#else
+// using the built-in allows to use glShadeModel
+#define COLOR gl_FrontColor
+#endif
+
 //#define fog packed_data_1.w
 #define E 2.718281828459045
 /* this doesn't work for setting fog_color, need to set the values independently */
diff --git a/layer0/ShaderPrg.cpp b/layer0/ShaderPrg.cpp
index 87747d7..0f1656a 100644
--- a/layer0/ShaderPrg.cpp
+++ b/layer0/ShaderPrg.cpp
@@ -153,7 +153,7 @@ int CShaderPrg::Enable() {
   /* if so, use the program */
   glUseProgram(id);
   // uniform 
-  Set1i("isPicking", G->ShaderMgr->is_picking);
+  Set1i("isPicking", SettingGetGlobal_b(G, cSetting_pick_shading) ? 1 : G->ShaderMgr->is_picking);
   return 1;
 }
 
diff --git a/layer1/Ortho.cpp b/layer1/Ortho.cpp
index c94a2a3..a0510ec 100644
--- a/layer1/Ortho.cpp
+++ b/layer1/Ortho.cpp
@@ -2896,7 +2896,7 @@ void OrthoPushMatrix(PyMOLGlobals * G)
     glDisable(GL_DITHER);
 
 #ifndef PURE_OPENGL_ES_2
-    glShadeModel(GL_SMOOTH);
+    glShadeModel(SettingGetGlobal_b(G, cSetting_pick_shading) ? GL_FLAT : GL_SMOOTH);
 #endif
     if(G->Option->multisample)
       glDisable(0x809D);        /* GL_MULTISAMPLE_ARB */
diff --git a/layer1/Scene.cpp b/layer1/Scene.cpp
index 91d5f05..fe02f3a 100644
--- a/layer1/Scene.cpp
+++ b/layer1/Scene.cpp
@@ -5675,6 +5675,32 @@ static int SceneDeferredImage(DeferredImage * di)
       " Warning: Clipboard image transfers disabled in Evaluation builds.\n" ENDFB(G);
 #endif
 #endif
+#ifndef _PYMOL_NOPY
+  } else {
+    auto raw_image_callback = PyObject_GetAttrString(G->P_inst->cmd, "raw_image_callback");
+    if (raw_image_callback != Py_None) {
+      int blocked = PAutoBlock(G);
+      auto& image = G->Scene->Image;
+
+#ifdef _PYMOL_NUMPY
+      // RGBA image as uint8 numpy array
+      import_array1(0);
+      npy_intp dims[3] = {image->width, image->height, 4};
+      auto py = PyArray_SimpleNew(3, dims, NPY_UINT8);
+      memcpy(PyArray_DATA((PyArrayObject *)py), image->data, dims[0] * dims[1] * 4);
+#else
+      // RGBA image as byte string
+      auto py = PyBytes_FromStringAndSize(
+          reinterpret_cast<const char*>(image->data),
+          image->width * image->height * 4);
+#endif
+
+      PYOBJECT_CALLFUNCTION(raw_image_callback, "O", py);
+      Py_DECREF(py);
+      PAutoUnblock(G, blocked);
+    }
+    Py_DECREF(raw_image_callback);
+#endif
   }
   return 1;
 }
diff --git a/layer1/ScenePicking.cpp b/layer1/ScenePicking.cpp
index d821890..7551ece 100644
--- a/layer1/ScenePicking.cpp
+++ b/layer1/ScenePicking.cpp
@@ -276,7 +276,7 @@ void SceneRenderPickingSinglePick(PyMOLGlobals * G, SceneUnitContext *context, P
      bg_grad() might be called in OrthoDoDraw() before GL 
      settings are set in SceneRender() */
   //      glEnable(GL_COLOR_MATERIAL);
-  glShadeModel(GL_SMOOTH);
+  glShadeModel(SettingGetGlobal_b(G, cSetting_pick_shading) ? GL_FLAT : GL_SMOOTH);
 #endif
 }
 
@@ -477,7 +477,7 @@ void SceneRenderPickingMultiPick(PyMOLGlobals * G, SceneUnitContext *context, Mu
      bg_grad() might be called in OrthoDoDraw() before GL 
      settings are set in SceneRender() */
   //      glEnable(GL_COLOR_MATERIAL);
-  glShadeModel(GL_SMOOTH);
+  glShadeModel(SettingGetGlobal_b(G, cSetting_pick_shading) ? GL_FLAT : GL_SMOOTH);
 #endif
   VLAFreeP(lowBitVLA);
   VLAFreeP(highBitVLA);
diff --git a/layer1/SceneRender.cpp b/layer1/SceneRender.cpp
index 78f98b0..1cc0661 100644
--- a/layer1/SceneRender.cpp
+++ b/layer1/SceneRender.cpp
@@ -389,7 +389,7 @@ void SceneRender(PyMOLGlobals * G, Picking * pick, int x, int y,
       if (ALWAYS_IMMEDIATE_OR(!use_shaders)) {
       glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
       glEnable(GL_COLOR_MATERIAL);
-      glShadeModel(GL_SMOOTH);
+      glShadeModel(SettingGetGlobal_b(G, cSetting_pick_shading) ? GL_FLAT : GL_SMOOTH);
 
       if (use_shaders) {
         glDisable(GL_ALPHA_TEST);
@@ -1530,7 +1530,7 @@ void SceneDrawStencilInBuffer(PyMOLGlobals * G, CScene *I, int stereo_mode){
   glDisable(GL_NORMALIZE);
   glDisable(GL_COLOR_MATERIAL);
   glDisable(GL_LINE_SMOOTH);
-  glShadeModel(GL_SMOOTH);
+  glShadeModel(SettingGetGlobal_b(G, cSetting_pick_shading) ? GL_FLAT : GL_SMOOTH);
   glDisable(0x809D);      /* GL_MULTISAMPLE_ARB */
 #endif
   
diff --git a/layer1/SettingInfo.h b/layer1/SettingInfo.h
index aeeeb1c..32f69fa 100644
--- a/layer1/SettingInfo.h
+++ b/layer1/SettingInfo.h
@@ -862,6 +862,7 @@ enum {
   REC_i( 754, auto_show_classified                    , global    , 0, 0, 3 ), // 0: off, 1: as, 2: show, 3: simple
   REC_b( 755, collada_background_box                  , global    , 0 ),
   REC_b( 756, pick32bit                               , global    , 1 ),
+  REC_b( 757, pick_shading                            , global    , 0 ),
 
 #ifdef SETTINGINFO_IMPLEMENTATION
 #undef SETTINGINFO_IMPLEMENTATION
diff --git a/layer4/Cmd.cpp b/layer4/Cmd.cpp
index c057893..03fe7aa 100644
--- a/layer4/Cmd.cpp
+++ b/layer4/Cmd.cpp
@@ -65,6 +65,7 @@ Z* -------------------------------------------------------------------
 #include"Executive.h"
 #include"Selector.h"
 #include"main.h"
+#include"SceneDef.h"
 #include"Scene.h"
 #include"SceneRay.h"
 #include"Setting.h"
@@ -6202,6 +6203,34 @@ static PyObject *CmdRefreshNow(PyObject * self, PyObject * args)
   return APISuccess();
 }
 
+static PyObject *CmdGetRawImage(PyObject * self, PyObject * args)
+{
+  PyMOLGlobals *G = NULL;
+  PyObject * result = NULL;
+
+  if(!PyArg_ParseTuple(args, "O", &self)) {
+    API_HANDLE_ERROR;
+    ok_raise(1);
+  }
+
+  API_SETUP_PYMOL_GLOBALS;
+  ok_assert(1, G && APIEnterNotModal(G));
+
+  if (SceneHasImage(G)) {
+    auto& image = G->Scene->Image;
+    result = PyBytes_FromStringAndSize(
+        reinterpret_cast<const char*>(image->data),
+        image->width * image->height * 4);
+  } else {
+    PRINTFB(G, FB_CCmd, FB_Errors)
+      " CmdGetRawImage-Error: SceneHasImage is false\n" ENDFB(G);
+  }
+
+  APIExit(G);
+ok_except1:
+  return APIAutoNone(result);
+}
+
 static PyObject *CmdPNG(PyObject * self, PyObject * args)
 {
   PyMOLGlobals *G = NULL;
@@ -8805,6 +8834,7 @@ static PyMethodDef Cmd_methods[] = {
   {"p_glut_event", CmdPGlutEvent, METH_VARARGS},
   {"p_glut_get_redisplay", CmdPGlutGetRedisplay, METH_VARARGS},
   {"paste", CmdPaste, METH_VARARGS},
+  {"get_raw_image", CmdGetRawImage, METH_VARARGS},
   {"png", CmdPNG, METH_VARARGS},
   {"pop", CmdPop, METH_VARARGS},
   {"protect", CmdProtect, METH_VARARGS},
diff --git a/modules/pymol/cmd.py b/modules/pymol/cmd.py
index dcc59f8..7f68173 100644
--- a/modules/pymol/cmd.py
+++ b/modules/pymol/cmd.py
@@ -392,6 +392,8 @@ with a slash (/) forces the interpreter to pass it to Python. See also the
 
         color_sc = None
 
+        raw_image_callback = None
+
     except:
         print("Error: unable to initalize the pymol.cmd module")
         traceback.print_exc()
diff --git a/modules/pymol/experimenting.py b/modules/pymol/experimenting.py
index 8036410..4def964 100644
--- a/modules/pymol/experimenting.py
+++ b/modules/pymol/experimenting.py
@@ -519,3 +519,12 @@ ARGUMENTS
             return 0x40000000 + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]
         _self.alter(selection, "color = desat(color)", space={'desat': desat})
         _self.recolor()
+
+    def get_raw_image(_self=cmd):
+        '''
+DESCRIPTION
+
+    Get the last rendered image as an RGBA byte array.
+        '''
+        with _self.lockcm:
+            return _cmd.get_raw_image(_self._COb)
